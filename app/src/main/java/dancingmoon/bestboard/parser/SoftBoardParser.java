package dancingmoon.bestboard.parser;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.AsyncTask;
import android.os.Environment;
import android.preference.PreferenceManager;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.security.InvalidKeyException;
import java.util.ArrayList;
import java.util.List;

import dancingmoon.bestboard.debug.Debug;
import dancingmoon.bestboard.R;
import dancingmoon.bestboard.SoftBoardData;
import dancingmoon.bestboard.SoftBoardData.SoftBoardListener;
import dancingmoon.bestboard.scribe.Scribe;
import dancingmoon.bestboard.utils.ExtendedMap;
import dancingmoon.bestboard.utils.ExternalDataException;


public class SoftBoardParser extends AsyncTask<Void, Void, Integer>
	{
	/**
	 ** PRIVATE VARIABLES
	 **/
	
	/** IN: Board descriptor file source contains board data in human readable coat format */
	private File descriptorFile;


	/** OUT: Softboard's data generated from descriptor file on the background thread */

    // parseDescriptorFile creates tokenizer - temporary
    private Tokenizer tokenizer;

    // parseSoftBoard creates softBoardata
	private SoftBoardData softBoardData;

    // parseSoftBoard creates labels - temporary
    private Labels labels;

    // (Static) Commands class is needed, too

    // SoftBoardData.RichCodes should be used for Rich- and TextCodes


    /**
     ** INNER EXCEPTIONS
     **/

    /**
     * Asynctask was cancelled expicitly
     * (It has only the default constructor without parameters.
     *  The needed serialVersionUID was generated by Android Studio)
     */
    private class TaskCancelledException extends Exception
        {
        private static final long serialVersionUID = -6627468069410136263L;
        }

    /**
     * Cannot validate coat file (because COAT is NOT the first token)
     * (It has only the default constructor without parameters.
     *  The needed serialVersionUID was generated by Android Studio)
     */
    private class InvalidCoatFileException extends Exception
        {
        private static final long serialVersionUID = 1165412659034734800L;
        }

    /**
     ** CRITICAL ERRORS ON BACKGROUND THREAD
     ** All values should be negative!!
     **/

    /** Background task was cancelled - this is not a real error, but task was not finished */
    public static final int CANCEL = -1;

    /** Could not find descriptor file */
    public static final int CRITICAL_FILE_NOT_FOUND_ERROR = -2;

    /** IO error reading descriptor file */
    public static final int CRITICAL_IO_ERROR = -3;

    /** Not valid descriptor file */
    public static final int CRITICAL_NOT_VALID_FILE_ERROR = -4;

    /** Critical error during parsing phase: no board is defined */
    public static final int CRITICAL_PARSING_ERROR = -5;


    /**
     ** ASYNCTASK - CONNECTION TO CALLER PART
     **/

	/** Asynctask's caller - context and callbacks */
	private SoftBoardParserListener caller;
	
	/** The interface of asynctask's caller */
	public interface SoftBoardParserListener
		{
		/**
		 * Get application context. 
		 * This method is definied by both Service and Activity.
		 * @return application context
		 */
		Context getApplicationContext();

        SoftBoardListener getSoftBoardDataListener();

		/**
		 * Callback method is called after background task has finished without critical errors.
		 * @param softBoardData newly generated class containing all softboard data 
		 * @param errorCount number of non-critical errors (error messages can be found in the log)
		 */
		void softBoardParserFinished(SoftBoardData softBoardData, int errorCount);
		
		/**
		 * Callback method is called after critical error has stopped the background task.
		 * @param errorInfo id of the critical error
		 */
		void softBoardParserCriticalError(int errorInfo);
		}

	
	/**
	 * Constructor is used instead of standard AsyncTask params,
	 * because there are parameters with different types. 
	 * http://stackoverflow.com/questions/16765415/should-i-give-params-to-the-constructor-or-to-asynctask-executeparams 
	 * @param caller SoftBoardService implementing SoftBoardParserListener
	 * @param descriptorFile descriptor (coat) file
	 */
	public SoftBoardParser(SoftBoardParserListener caller, File descriptorFile)
		{
        super();

        Scribe.locus( Debug.PARSER );

		this.caller = caller;
		this.descriptorFile = descriptorFile;
		}


	/**
	 * Background thread will parse information from descriptor file into softBoardData class.
	 * Cancellation is signalled as CancellationException through the inner methods.
	 * @return 0: ok;
	 * negative values: critical error, execution was stopped;
	 * positive values: non-critical errors were logged, execution was finished successfully
	 */
	@Override
	protected Integer doInBackground(Void... voids)
		{
        Scribe.locus( Debug.PARSER );

        try
            {
            return parseDescriptorFile( descriptorFile );
            }
        catch (TaskCancelledException tce)
            {
            // onCancelled() is called, but we do not need it, as caller was destroyed
            return CANCEL;
            }
        catch (FileNotFoundException fnfe)
            {
            return CRITICAL_FILE_NOT_FOUND_ERROR;
            }
        catch (IOException ioe)
            {
            return CRITICAL_IO_ERROR;
            }
        catch (InvalidCoatFileException icfe)
            {
            return CRITICAL_NOT_VALID_FILE_ERROR;
            }
        catch (ExternalDataException ede)
            {
            return CRITICAL_PARSING_ERROR;
            }
        }

	/**
	 * Background work was finished.
	 * (Cancellation calls onCancel(), this method is NOT called!)
	 * @param error 0: ok;
	 * negative values: critical error, execution was stopped;
	 * positive values: non-critical errors were logged, execution was finished successfully
	 */
	@Override
	protected void onPostExecute(Integer error)
		{
        Scribe.locus( Debug.PARSER );

		if ( error >= 0 )
			caller.softBoardParserFinished(softBoardData, error);
		else
			caller.softBoardParserCriticalError(error);
		}


    /**********************************************************************************************
     **                                   P A R S E R  P A R T                                   **
     **********************************************************************************************/

    /**
     * Tokenizer stream is created from descriptor file.
     * Parser methods work on this tokenizer.
     * @param descriptorFile descriptor (coat) file
     * @return number of non-critical errors (0 - ok)
     * @throws TaskCancelledException background thread was cancelled by the caller
     * @throws FileNotFoundException descriptor (coat) file missing
     * @throws IOException  descriptor (coat) file reading fails
     * @throws InvalidCoatFileException descriptor file is not valid (COAT should be the first token!)
     */
    public int parseDescriptorFile(File descriptorFile) throws TaskCancelledException, IOException, InvalidCoatFileException, ExternalDataException
        {
        Scribe.locus( Debug.PARSER );
        Scribe.note_secondary(caller.getApplicationContext().getString(R.string.parser_starting));

        // Descriptor file check
        if ( descriptorFile==null || !descriptorFile.exists() || !descriptorFile.isFile())
            {
            Scribe.error_secondary( caller.getApplicationContext().getString( R.string.parser_no_coat_file ) );
            throw new FileNotFoundException();
            }

        BufferedReader reader = null;

        try
            {
            reader = new BufferedReader( new InputStreamReader( new FileInputStream( descriptorFile ), "UTF-8" ) );
            tokenizer = new Tokenizer( caller.getApplicationContext(), reader );

            parseSoftBoard( );
            }

        // TaskCancelledException, IOException, InvalidCoatFileException are not catched,
        // these are thrown back to doInBackground()!

        finally
            {
            if (reader != null)
                {
                try
                    {
                    reader.close();
                    }
                catch (IOException ioe)
                    {
                    Scribe.error("ERROR IN CLOSE (Descriptor file processing) " + ioe.toString());
                    }
                }
            }

        // Both error counts (from the tokenizer and from the parser) will be returned
        return tokenizer.getErrorCount();
        }


    /**
     * Creates a new Labels class, then starts parsing
     * of the parameter list of the virtual ADDSOFTBOARD command.
     * @throws TaskCancelledException background thread was cancelled by the caller
     * @throws IOException descriptor (coat) file reading fails
     * @throws InvalidCoatFileException descriptor file is not valid (COAT should be the first token!)
     */
    private void parseSoftBoard()
            throws TaskCancelledException, IOException, InvalidCoatFileException, ExternalDataException
        {
        Scribe.locus( Debug.PARSER );

        Object temp;
        // COAT 2 - MUST BE the first parameter-command!
        // It is NOT part of the Commands class, it will be checked "manually"
        if ( tokenizer.nextToken() != Tokenizer.TYPE_KEYWORD ||
                tokenizer.getIntegerToken() != Commands.TOKEN_COAT ||
                (temp = parseOneParameter( Commands.PARAMETER_LONG)) == null ||
                (long)temp != Commands.COAT_VERSION )
            {
            tokenizer.error( R.string.parser_coat_file_invalid, String.valueOf(Commands.COAT_VERSION) );
            throw new InvalidCoatFileException();
            }
        else
            {
            tokenizer.note( R.string.parser_coat_file_ok, String.valueOf( Commands.COAT_VERSION ) );
            }

        softBoardData = new SoftBoardData( caller.getSoftBoardDataListener(), tokenizer );
        labels = Commands.createLabels();

        try
            {
            tokenizer.note( R.string.parser_file_parsing_started );
            parseComplexParameter( Commands.ADDSOFTBOARD, Commands.get( Commands.ADDSOFTBOARD).getAllowedParameters() );
            if ( tokenizer.getTokenType() == Tokenizer.TYPE_EOF )
                tokenizer.note( R.string.parser_file_parsing_finished );
            else
                tokenizer.error( R.string.parser_file_parsing_interrupted );
            }
        catch (InvalidKeyException e)
            {
            tokenizer.error( R.string.parser_addsoftboard_data_missing );
            }

        softBoardData.parsingFinished();
        }


    /**
     * Parses a complex parameter-command list, without parentheses.
     * Each parameter-command in the list is evaluated,
     * and the method of each parameter-command is called
     * with the appropriate parameter list.
     * Returns the return-values of each parameter-command
     * identified by the token-code of its command.
     * @param parsedCommandCode parameters of this command are evaluated
     * @param allowedParameterCommands allowed parameters for this command
     * Usually code determines allowed parameters (through the data class),
     * but this is not obligatory. Code is used only if a comlpex label is given.
     * @return return-values of the parameters in the list
     * @throws IOException (coat) file reading fails
     */
    private ExtendedMap<Long, Object> parseComplexParameter( long parsedCommandCode,
                                                             long[] allowedParameterCommands )
            throws IOException
        {
        int tokenType;
        
        // Parameter-command's code and data
        long commandCode;
        String commandString; // Just for debugging
        Commands.Data commandData;

        // Complex parameter-list forwarded to the method
        ExtendedMap<Long, Object> forwardParameters = null;

        // Result from the method - or the value of the one-parameter 
        Object result;

        // Parameter list (results of the called methods of the parameter-commands) will be returned to the caller
        // Every cycle can give a new item to returnParameters
        ExtendedMap<Long, Object> returnParameters = new ExtendedMap<>();

        // iterate the parameter-commands of the caller
        while (true)
            {
            // FIRST: token should be an allowed parameter-command keyword
            tokenType = tokenizer.nextToken();

            // Checking valid parameter-commands
            if ( tokenType == Tokenizer.TYPE_KEYWORD )
                {
                commandCode = tokenizer.getIntegerToken();
                commandString = tokenizer.getStringToken();
                // tokenizer.note( commandString, R.string.parser_code, Long.toHexString(commandCode) );

                // Valid keyword, but not allowed parameter-command - this can be a label
                if ( !contains( allowedParameterCommands, commandCode ) )
                    {
                    try
                        {
                        // label key is given as commandCode, while type is the parsed commandCode
                        forwardParameters = (ExtendedMap<Long, Object>) labels
                                .get( commandCode, parsedCommandCode );

                        // All elements are copied into returnedParameters
                        // !! WARNING !! ADDTITLE elements are overwritten instead of adding !!
                        // !! This will work only after implementing multiple parameters
                        returnParameters.putAll( forwardParameters );
                        }
                    catch (InvalidKeyException e)
                        {
                        tokenizer.error(commandString, R.string.parser_parameter_invalid,
                                Tokenizer.regenerateKeyword( commandCode ));
                        // parameter-block (if any) will be skipped as unexpected block
                        }

                    // this token (label) was consumed, cycle to the next token
                    continue;
                    }

                // An allowed parameter-command is ready here, step to second
                }

            // Parsing of complex parameter finishes here
            else if ( tokenType == Tokenizer.TYPE_END || tokenType == Tokenizer.TYPE_EOF )
                {
                break;
                }

            // Unexpected block should be skipped
            else if ( tokenType == Tokenizer.TYPE_START )
                {
                tokenizer.error( R.string.parser_block_skipped );
                tokenizer.pushBackLastToken();
                tokenizer.skipBlock();
                continue;
                }

            // Character, Fraction, Integer, String, (Eol) are not allowed!
            else
                {
                tokenizer.error( R.string.parser_command_missing, tokenizer.getStringToken());
                continue;
                }


            // SECOND: we should evaluate the parameter-list of the checked parameter-command
            // Data of the parameter-command is needed
            try
                {
                commandData = Commands.get( commandCode );
                }
            catch (InvalidKeyException e)
                {
                tokenizer.error( commandString, R.string.parser_data_missing);
                // parameter-block (if any) will be skipped as unexpected block
                continue;
                }

            // Type can be:
            // Complex parameter:
            //      Parameters for method: forwardParameters (ExtendedMap)
            //      Returned value: result of the method (if any) - or nothing
            // One parameter
            //      Parameters for method: result (Object)
            //      Returned value: result of the method (if any) - or itself (result)
            // Label parameter
            //      No further method is called
            // Flag parameter - doesn't have any parameter, but still will be stored
            // among returnParameters with a fake Boolean.TRUE Object
            //      Parameters for method: none ()
            //      Returned value: result of the method (if any) - or a fake Object ( ?? )
            // No parameter
            //      Parameters for method: none ()
            //      Returned value: result of the method (if any) or nothing

            // Result is cleared here, because it can contain the parameter itself (one-parameter)
            // Or the result of the method (if any), or should be null
            result = null;

            // Parameter-command has COMPLEX parameters
            if ( commandData.getParameterType() >= 0L )
                {
                // surrounding parentheses are checked here
                if (tokenizer.nextToken() != Tokenizer.TYPE_START)
                    {
                    tokenizer.error(commandString, R.string.parser_list_missing);
                    tokenizer.pushBackLastToken();
                    continue;
                    }

                // tokenizer.note( commandString, R.string.parser_complex_started);
                forwardParameters = parseComplexParameter(commandCode, commandData.getAllowedParameters());

                // forward results of previous parameter-commands with the same code to method
                // forwarded value can be null
                forwardParameters.put(commandCode, returnParameters.get(commandCode));

                // END and EOF can be returned, but evaluation can be performed normally
                if (tokenizer.nextToken() != Tokenizer.TYPE_END)
                    {
                    tokenizer.error(commandString, R.string.parser_bracket_missing);
                    }
                // tokenizer.note( commandString, R.string.parser_complex_finished, forwardParameters.toString() );

                // parameters for method are in forwardParameters, result is cleared
                }

            // Parameter-command has ONE parameter
            else if ( commandData.getParameterType() >= Commands.PARAMETER_KEYWORD )
                {
                result = parseOneParameter( commandData.getParameterType());
                // tokenizer.note( commandString, R.string.parser_one_finished, result.toString() );
                if ( result ==null )
                    {
                    // There was an error, log was already sent, but this parameter cannot be consumed
                    continue;
                    }

                // parameters for method are in result
                }

            // Parameter-command has LIST parameter
            else if ( commandData.getParameterType() >= (Commands.PARAMETER_KEYWORD & Commands.PARAMETER_MODE_LIST) )
                {
                result = parseListParameter( commandData.getParameterType() );
                // tokenizer.note( commandString, R.string.parser_list_finished, result.toString() );
                if ( result ==null )
                    {
                    // List is completely missing, log was already sent,
                    // but this parameter cannot be consumed
                    continue;
                    }

                // parameters for method are in result
                }

            // Parameter-command has LABEL parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_LABEL )
                {
                parseLabelParameter();
                continue;

                // no method to call; no result to return
                }

            // Parameter-command has FLAG parameter
            else if ( commandData.getParameterType() == Commands.PARAMETER_FLAG )
                {
                // fake Object is needed to be stored among returnParameters
                result = true;
                }

            // Parameter-command is a special STOP message
            else if ( commandData.getParameterType() == Commands.MESSAGE_STOP )
                {
                // force to finish this block
                tokenizer.stopBlock();
                break;
                }

            // Parameter-command has NO parameters
            // else
            // No parameters for method, result remains null

            // THIRD: method is called with the appropriate parameters
            // Returned value (if any) is put into returnParameters
            if ( commandData.hasMethodToCall() )
                {
                // tokenizer.note( commandString, R.string.parser_method_called );
                try
                    {
                    // Different types of methods should be called - according to parameter type

                    // Parameter-command has COMPLEX parameters - forwardParameters
                    if ( commandData.getParameterType() >= 0L )
                        result = commandData.getMethod().invoke(softBoardData.methodsForCommands, forwardParameters );
                    // Parameter-command has ONE parameter - result
                    else if ( commandData.getParameterType() >= Commands.PARAMETER_KEYWORD )
                        result = commandData.getMethod().invoke(softBoardData.methodsForCommands, result );
                    // Parameter-command has LIST parameter - result
                    else if ( commandData.getParameterType() >= ( Commands.PARAMETER_KEYWORD & Commands.PARAMETER_MODE_LIST) )
                        result = commandData.getMethod().invoke(softBoardData.methodsForCommands, (List)result );
                    // Parameter-command has NO or FLAG parameters - no parameters
                    else
                        result = commandData.getMethod().invoke(softBoardData.methodsForCommands );
                    // Label-parameters cannot arrive here

                    // if ( result != null )
                        // tokenizer.note( commandString, R.string.parser_result, result.toString() );
                    // else
                        // tokenizer.note( commandString, R.string.parser_method_no_result );
                    }
                catch (IllegalAccessException e)
                    {
                    tokenizer.error( commandString, R.string.parser_cannot_access_method );
                    // if result was ready (one-parameter) it will be still part of the returnedParameters
                    // but this is NOT the result of the method!
                    }
                catch (InvocationTargetException e)
                    {
                    tokenizer.error( commandString, R.string.parser_method_exception );
                    // if result was ready (one-parameter) it will be still part of the returnedParameters
                    // but this is NOT the result of the method!
                    }
                }
            // else
                // tokenizer.note( commandString, R.string.parser_no_method_called );

            // if result is not null, it will part of the returnParameters as commandCode-result pair
            if (result != null)
                {
                // if there was a previous result - it is overwritten
                returnParameters.put(commandCode, result);
                }

            } // end of cycle

        // Cycle finished with STOP or EOF - but we must not consume the terminating STOP token
        tokenizer.pushBackLastToken();

        return returnParameters;

        //Char End Eof Eol Fract Int Keyword String Start
        }


    /**
     * Parses one-parameter type parameters. Parameter can be inside parentheses.
     * Currently BOOLEAN (Boolean), CHAR(Long), COLOR(Integer), LONG(Long),
     * FILE(String), STRING(String) and KEYWORD(Long) can be parsed.
     * The method will find LABELS as well.
     * The precision of numeric values will be checked.
     * CHAR precision numeric values can be returned as string.
     * @param parameterType as defined in the Commands class
     * @return the value of the parameter, or null if parameter is invalid
     * @throws IOException (coat) file reading fails
     */
    private Object parseOneParameter( long parameterType) throws IOException
        {
        String forParameter = tokenizer.getStringToken();

        Object result; // null == error
        boolean bracket = false;

        // 1st - optional - token is OPENING BRACKET
        if ( tokenizer.nextToken() == Tokenizer.TYPE_START )
            {
            bracket = true;
            }
        else
            {
            tokenizer.pushBackLastToken();
            }

        // 2nd token is PARAMETER - null and error message, if invalid
        result = parseParameter( parameterType, true, forParameter );

        // 3rd token CLOSING BRACKET (If bracket was opened, it should also be closed)
        if ( bracket )
            {
            if ( tokenizer.nextToken() != Tokenizer.TYPE_END )
                {
                tokenizer.error( forParameter, R.string.parser_bracket_missing );
                tokenizer.pushBackLastToken();
                // There are several ways to resolve this mistake.
                // Result (if ready) is returned, invalid token is pushed back for further analysis
                }
            }

        // tokenizer.note( forParameter, R.string.parser_result, result.toString() );
        // Returning result
        return result;
        }


    /**
     * Parses list of one-parameter type parameters.
     * List elements should have the same type.
     * Each parameter of the list is get by parseOneParameter().
     * @param parameterType as defined in the Commands class
     * (can be one-parameter or list-parameter type)
     * @return list of the parameter values as an array-list, or null if list is completely missing
     * @throws IOException (coat) file reading fails
     */
    private List<Object> parseListParameter( long parameterType) throws IOException
        {
        String forParameter = tokenizer.getStringToken();

        List<Object> result = new ArrayList<>();
        Object element;

        // 1st token is obligatory OPENING-BRACKET
        if ( tokenizer.nextToken() != Tokenizer.TYPE_START )
            {
            tokenizer.error( forParameter, R.string.parser_value_list_missing);
            tokenizer.pushBackLastToken();
            return null;
            }

        // 5. bit of parameter type should be turned 1
        parameterType |= -16L;

        // Next tokens: one-parameter type tokens, terminated by TYPE_END
        while ( true )
            {
            element = parseParameter( parameterType, false, forParameter );

            // only valid elements are added
            if ( element != null )
                {
                result.add( element );
                }

            // token evaluation should be continued, if returned value is not valid

            // Termination should be evaluated first, not to send error message
            else if ( tokenizer.getTokenType() == Tokenizer.TYPE_END )
                {
                break;
                }
            // element is invalid because of EOF
            else if ( tokenizer.getTokenType() == Tokenizer.TYPE_EOF )
                {
                tokenizer.error( forParameter, R.string.parser_bracket_missing );
                break;
                }
            }

        return result;
        }


    /**
     * Parses the parameters of the complex value inside the LET command.
     * Pattern: START (obligatory) - complex parameter - END (obligatory)
     * @param commandCode
     * @param commandString just for debug
     * @return complex evaluated by parseComplexParameter() (can be empty,
     * OR null if complex is not valid
     * @throws IOException
     */
    private ExtendedMap<Long, Object> parseComplexValue( long commandCode, String commandString ) throws IOException
        {
        ExtendedMap<Long, Object> result = null;
        Commands.Data commandData;

        // is command allowed? - if allowed it will be > 0
        if ( !contains( Commands.ALLOWED_LABELS, commandCode ) )
            {
            tokenizer.error( commandString, R.string.parser_label_complex_not_allowed );
            return null;
            }

        // get command's data
        try
            {
            commandData = Commands.get( commandCode );
            }
        catch (InvalidKeyException e)
            {
            // This cannot happen, because command is part of the allowed commands
            tokenizer.error( commandString, R.string.parser_data_missing);
            // parameter-block (if any) will be skipped as unexpected block
            return null;
            }

        // surrounding parentheses are checked here
        if (tokenizer.nextToken() != Tokenizer.TYPE_START)
            {
            tokenizer.error( commandString, R.string.parser_list_missing );
            tokenizer.pushBackLastToken();
            return null;
            }

        else
            {
            // tokenizer.note( commandString, R.string.parser_complex_started);
            result = parseComplexParameter( commandCode, commandData.getAllowedParameters() );

            // END and EOF can be returned, but evaluation can be performed normally
            if ( tokenizer.nextToken() != Tokenizer.TYPE_END )
                {
                tokenizer.error( commandString, R.string.parser_bracket_missing );
                }
            }

        return result;
        }


    /**
     * Parses parameters after LET command.
     * Parameters are special labelkey-labelvalue pairs, where labelkey is a keyword,
     * and labelvalue is one of TYPE_STRING, TYPE_CHARACTER, TYPE_INTEGER token.
     * These parameters are specially handled, because their type is not known previously,
     * and keywords (labels) are not accepted!
     * @throws IOException (coat) file reading fails
     */
    private void parseLabelParameter() throws IOException
        {
        // key part
        long key = 0L;
        String keyAsString = null; // just for logging

        // type part
        long type = 0L;

        // value part
        Object value = null;
        String valueAsString = null; // just for logging

        boolean error = false; // ?? is it really needed ?? or can be replaced by value == null

        // 1st token is obligatory OPENING-BRACKET
        int tokenType = tokenizer.nextToken();
        if ( tokenType != Tokenizer.TYPE_START )
            {
            tokenizer.error( R.string.parser_label_key_missing);
            tokenizer.pushBackLastToken();
            return;
            }

        // 2nd token is KEYWORD
        tokenType = tokenizer.nextToken();
        if ( tokenType == Tokenizer.TYPE_KEYWORD )
            {
            // correct label key
            key = tokenizer.getIntegerToken();
            keyAsString = tokenizer.getStringToken();
            }
        // 2nd and 3rd tokens are MISSING, closing-bracket is consumed
        else if ( tokenType == Tokenizer.TYPE_END )
            {
            tokenizer.error( R.string.parser_label_key_missing );
            return;
            }
        else if( tokenType == Tokenizer.TYPE_EOF )
            {
            tokenizer.error( R.string.parser_terminated );
            return;
            }
        // 2nd token is invalid
        else
            {
            tokenizer.error( R.string.parser_label_key_invalid, tokenizer.getStringToken());
            error = true;
            }

        //3rd token is VALUE
        tokenType = tokenizer.nextToken();

        // Value is string
        if ( tokenType == Tokenizer.TYPE_STRING )
            {
            type = Commands.PARAMETER_STRING;
            value = tokenizer.getStringToken();
            valueAsString = (String)value;
            }
        // Value is long (character or integer)
        else if ( tokenType == Tokenizer.TYPE_CHARACTER || tokenType == Tokenizer.TYPE_INTEGER )
            {
            type = Commands.PARAMETER_LONG;
            value = (Long) tokenizer.getIntegerToken();
            valueAsString = tokenizer.getStringToken();
            }
        // Value is complex
        else if ( tokenType == Tokenizer.TYPE_KEYWORD )
            {
            // key - already given
            // type - token of command, commandCode
            // value - parameters of command, evaluated by parseComplexParameter

            type = tokenizer.getIntegerToken();
            String typeString = tokenizer.getStringToken();

            value = parseComplexValue( type, typeString );
            if ( value == null )
                {
                // !! Error was already signed !!
                tokenizer.error( keyAsString, R.string.parser_label_complex_invalid );
                error = true;
                }
            else
                {
                valueAsString = typeString + ":" + value.toString();
                }
            }
        // 3rd token is MISSING, closing-bracket is consumed
        else if ( tokenType == Tokenizer.TYPE_END )
            {
            tokenizer.error( keyAsString, R.string.parser_label_value_missing );
            return;
            }
        else if ( tokenType == Tokenizer.TYPE_EOF )
            {
            tokenizer.error( keyAsString, R.string.parser_terminated );
            return;
            }
        // 3nd token is invalid
        else
            {
            tokenizer.error( keyAsString, R.string.parser_label_value_invalid, tokenizer.getStringToken());
            error = true;
            }

        // 4th token is obligatory CLOSING BRACKET
        tokenType = tokenizer.nextToken();
        if ( tokenType != Tokenizer.TYPE_END )
            {
            tokenizer.error( R.string.parser_bracket_missing);
            tokenizer.pushBackLastToken();
            // There are several ways to resolve this mistake.
            // Result (if ready) is returned, invalid token is pushed back for further analysis
            }

        // error was already logged
        if (error)
            return;

        // We have a correct label key-type-value pair
        error = labels.add(key, type, value);
        tokenizer.note( keyAsString, R.string.parser_label_added, valueAsString );

        // This label key was previously set!
        if ( error )
            {
            tokenizer.error( keyAsString, R.string.parser_label_overwritten );
            }

        }


    /**
     * Parses the next token according to one-parameter type parameters.
     * Currently BOOLEAN (Boolean), CHAR(Long), COLOR(Integer), LONG(Long),
     * FILE(String), STRING(String) and KEYWORD(Long) can be parsed.
     * The method will find LABELS as well.
     * The precision of numeric values will be checked.
     * CHAR precision numeric values can be returned as string.
     * If parameter is invalid then null is returned after an error message.
     * TYPE_END token is not consumed and no error message is sent!
     * @param parameterType as defined in the Commands class
     * @param obligatory if parameter is obligatory (TYPE_END sends error message)
     * @param forParameter textual name of parameter-command (just for debugging)
     * @return the value of the parameter, or null if parameter is invalid
     * @throws IOException (coat) file reading fails
     */
    private Object parseParameter( long parameterType, boolean obligatory, String forParameter ) throws IOException
        {
        Object result = null; // null == error

        int tokenType = tokenizer.nextToken();
        try
            {
            // 2nd token is PARAMETER token
            if ( tokenType == Tokenizer.TYPE_INTEGER )
                {
                // BOOLEAN CHAR COLOR INT LONG
                if ( parameterType >= Commands.PARAMETER_LONG )
                    {
                    // Parameter: NUMERIC, Token: NUMERIC, Return: LONG
                    result = tokenizer.getIntegerToken();
                    }
                else if ( parameterType == Commands.PARAMETER_TEXT)
                    {
                    // Parameter: TEXT, Token: INTEGER, Return: CHARACTER (from char)
                    result = tokenizer.getIntegerToken();
                    // result will be checked as character
                    parameterType = Commands.PARAMETER_CHAR;
                    }
                else // file, string and keyword parameter types
                    tokenizer.error( forParameter, R.string.parser_invalid_numeric );
                }

            else if ( tokenType == Tokenizer.TYPE_CHARACTER )
                {
                // BOOLEAN CHAR COLOR INT LONG
                if ( parameterType >= Commands.PARAMETER_LONG )
                    {
                    // Parameter: NUMERIC, Token: CHARACTER, Return: LONG
                    result = tokenizer.getIntegerToken();
                    }
                else if ( parameterType == Commands.PARAMETER_TEXT)
                    {
                    // Parameter: TEXT, Token: CHARACTER, Return: CHARACTER (from char)
                    result = tokenizer.getIntegerToken();
                    // result will be checked as character
                    parameterType = Commands.PARAMETER_CHAR;
                    }
                else // file, string, keyword parameter types
                    tokenizer.error( forParameter, R.string.parser_invalid_character );
                }

            else if ( tokenType == Tokenizer.TYPE_STRING )
                {
                // STRING FILE
                if ( parameterType < Commands.PARAMETER_LONG && parameterType >= Commands.PARAMETER_STRING )
                    {
                    // Parameter: STRING, Token: STRING, Return: STRING
                    result = tokenizer.getStringToken();
                    }
                else if ( parameterType == Commands.PARAMETER_TEXT)
                    {
                    // Parameter: TEXT, Token: STRING, Return: STRING (from string)
                    result = tokenizer.getStringToken();
                    // result will be checked as string
                    parameterType = Commands.PARAMETER_STRING;
                    }
                else  // numeric (BOOLEAN CHAR COLOR INT LONG), keyword parameter types
                    tokenizer.error( forParameter, R.string.parser_invalid_string );
                }

            else if ( tokenType == Tokenizer.TYPE_KEYWORD )
                {
                long key = tokenizer.getIntegerToken();

                if ( parameterType == Commands.PARAMETER_KEYWORD )
                    {
                    // Parameter: KEYWORD, Token: KEYWORD, Return: LONG (code from keyword)
                    result = key;
                    }

                // 2nd token is LABEL token
                else
                    {
                    // CHAR COLOR INT LONG
                    if ( parameterType >= Commands.PARAMETER_LONG )
                        {
                        // RETURN VALID LONG INTEGER (LABEL)
                        result = labels.getLongValue( key );
                        }
                    // FILE STRING
                    else if ( parameterType >= Commands.PARAMETER_STRING )
                        {
                        // RETURN VALID STRING (LABEL)
                        result = labels.getStringValue(key);
                        }
                    else if ( parameterType == Commands.PARAMETER_TEXT)
                        {
                        labels.select( key );
                        if ( labels.isNumericSelected() )
                            {
                            // Parameter: TEXT, Token: KEYWORD (numeric type), Return: CHARACTER (from long/char)
                            result = (Long)labels.getValueOfSelected();
                            parameterType = Commands.PARAMETER_CHAR;
                            }
                        else if ( labels.isStringSelected() )
                            {
                            // Parameter: TEXT, Token: KEYWORD (string type), Return: STRING (from string)
                            result = (String) labels.getValueOfSelected();
                            parameterType = Commands.PARAMETER_STRING;
                            }
                        // Complex labels are not allowed here
                        }
                    else
                        tokenizer.error( forParameter, R.string.parser_invalid_keyword );
                    }
                }
            // Obligatory: 2nd token is MISSING, 3rd token is pushed back (it should not be consumed)
            // Non-obligatory: token is valid, and will be evaluated later
            else if ( tokenType == Tokenizer.TYPE_END )
                {
                if ( obligatory )
                    {
                    tokenizer.error( forParameter, R.string.parser_value_missing );
                    // token is not consumed!
                    tokenizer.pushBackLastToken();
                    }
                // if non-obligatory - further evaluation will be performed
                }
            // 2nd token is MISSING, descriptor file is terminated
            else if ( tokenType == Tokenizer.TYPE_EOF )
                {
                tokenizer.error( forParameter, R.string.parser_terminated );
                }
            // 2nd token is invalid
            else // TOKEN_FRACTION, TOKEN_START
                {
                tokenizer.error( forParameter, R.string.parser_value_invalid );
                }
            }
        catch (InvalidKeyException ike)
            {
            tokenizer.error( forParameter, R.string.parser_no_label, tokenizer.getStringToken());
            }

        if ( result != null )
            {
            // Precision check for BOOLEAN parameter
            if ( parameterType == Commands.PARAMETER_BOOLEAN )
                {
                result = (long) result == 0 ? Boolean.FALSE : Boolean.TRUE;
                }

            // Precision check for CHAR parameter
            else if ( parameterType == Commands.PARAMETER_CHAR )
                {
                if ( (long) result < Character.MIN_VALUE || (long) result > Character.MAX_VALUE )
                    {
                    tokenizer.error( forParameter, R.string.parser_invalid_char_value, Long.toHexString( (long) result ) );
                    // result = (long) result & (long) Character.MAX_VALUE;
                    }
                long temp = (long) result;
                result = (char) temp;
                }

            // Precision check for COLOR parameter
            else if ( parameterType == Commands.PARAMETER_COLOR )
                {
                if ( (long) result < 0L || (long) result > 0xFFFFFFFFL )
                    {
                    tokenizer.error( forParameter, R.string.parser_invalid_color_value, Long.toHexString( (long) result ) );
                    // result = (long) result & 0xFFFFFFFFL;
                    }
                long temp = (long) result;
                result = (int) temp;
                }

            // Precision check for INT parameter
            else if ( parameterType == Commands.PARAMETER_INT )
                {
                if ( (long) result < Integer.MIN_VALUE || (long) result > Integer.MAX_VALUE )
                    {
                    tokenizer.error( forParameter, R.string.parser_invalid_int_value, String.valueOf( (long) result ) );
                    // result = (long) result & ??;
                    }
                long temp = (long) result;
                result = (int) temp;
                }

            // Precision check for FILE parameter
            else if ( parameterType == Commands.PARAMETER_FILE )
                {
                SharedPreferences sharedPrefs = PreferenceManager.
                        getDefaultSharedPreferences( caller.getApplicationContext() );
                String directoryName =
                        sharedPrefs.getString( caller.getApplicationContext().
                                getString( R.string.descriptor_directory_key ), "" );

                File directory = new File( Environment.getExternalStorageDirectory(), directoryName );
                File file = new File( directory, (String) result );

                if ( !file.exists() || !file.isFile() )
                    {
                    tokenizer.error( forParameter, R.string.parser_no_file, (String) result );
                    result = null;
                    }
                else
                    {
                    result = file;
                    }
                }
            }

        // tokenizer.note( forParameter, R.string.parser_result, result.toString() );

        // Error handling - error log was already sent; result is null
        // Returning result
        return result;
        }


    /**
     * Helper method to create String from PARAMETER_TEXT
     * @param text String or Character object - CANNOT CALLED WITH OTHER TYPES!
     * @return String equivalent
     * !! This method is only used for PARAMETER_TEXT,
     * but toString() could be used to make it more general.
     */
    public static String stringFromText( Object text )
        {
        if (text instanceof Character )
            return String.valueOf( (char)text );
        else // if ( temp instanceof String )
            return (String)text;
        }


    /**
     * Simple utility to check whether array contains item.
     * As generics don't support primitives, it is an extra method for long.
     * ((http://stackoverflow.com/questions/2721546/why-dont-java-generics-support-primitive-types ;
     * http://stackoverflow.com/a/12635769 a nice algorithm with generics ;
     * http://stackoverflow.com/questions/2250031/null-check-in-an-enhanced-for-loop))
     * !! Method could be added to Utils later
     * @param array to check (cannot be null!)
     * @param item to look for
     * @return true if array contains item
     */
    public static boolean contains(final long[] array, final long item)
        {
        for (final long i : array)
            if ( i == item )
                return true;

        return false;
        }

    }
